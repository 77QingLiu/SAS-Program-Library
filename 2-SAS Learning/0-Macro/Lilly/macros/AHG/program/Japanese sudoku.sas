/*sudoku_macro.sas*/
%let drive =C; /* Drive Name where SSS is saved */
%let folder =sudoku; /* Folder name where the result of execution of SSS will be saved
*/
%let program=sudoku; /* Folder name where three SAS programs of SSS are saved */
%let non=no; /* (1) No LOG information is displayed ="no"
(2) LOG information is displayed =" " */
%let star=*; /* (1) Only the final page of OUTPUT window is displayed ="*"
(2) All information of both LOG and OUTPUT windows are saved in
external filess =" " */
%let select_no=6; /* The No. of cells selected for Operation (3) */
*options mtrace macrogen;
* First of all, please save the following SAS programs in '&drive:\&folder'. ;
*(1) sudoku_macro.sas;
*(2) puzzle_make_original_data.sas;
*(3) puzzle_solve_final.sas;
* The users do not need to specify the macro variables below;
*(1) Full path of SSS engine, 'puzzle_solve_final.sas';
%let run_solve="&drive:\&program\puzzle_solve_final.sas";
*(2) Folder name where text files of Sudoku puzzles are saved. ;
%let problem_folder=&drive:\&folder\problem;
*=========================================================================;
%macro rotate(rotate_no);
%* Creates four SAS data sets, ORIGINALx1 to ORIGINALx4
by rotating the initial Sudoku puzzle 90 degrees clockwise three times.;
proc sort; by row; run;
data originalx&rotate_no;
array a {9} $ 1;
retain a1-a9;
set; by row;
do i=1 to 9; a{col}=x; end;
if last.row;
run;
ods listing close;
ods html file="&output\&Q.matrix&rotate_no..xls";
proc print; title"matrix&rotate_no"; run;
ods html close;
ods listing;
data initial;
keep x new_row new_col;
rename new_row=row new_col=col;
set initial;
new_row=col;
new_col=10-row;
run;
proc print; title"new matrix&rotate_no"; run;
%mend rotate;
*=========================================================================;
%macro set_rotate; %* Sets 90 degrees rotated board situation to ORIGINAL;
%if &rotate_sw=0 %then %do;
%let round=0; %* How many times 'puzzle_solve_final.sas' is recursively executed
for each candidate board situation during Operation (3).;
%let op3_no=0; %* The No. of candidate board situations created
in the beginning of Operation (3);
%let set3_no=0; %* The Identification number of candidate board situation
to currently be checked during the execution of Operation (3);
data original;

set originalx&rotate;
run;
%let rotate_sw=1;
%end;
%mend;
*=========================================================================;
%macro make_filter(dsname); %* Make 'filter' for each row, column and box. ;
data phase1;
drop i;
array a {9} $ 1;
array x {9};
array sw {9} $ 1;
set &dsname;
do i=1 to 9; if a{i}=0 then x{i}=123456789;
else do; if sw{a{i}}="Y" then call symput("wrong","1");
else do; sw{a{i}}="Y";
x{i}=a{i}*10**(9-a{i});
end;
end;
end;
run;
&star. proc print; title "ROUND &round: data=phase1(&dsname)"; run;
data phase2;
drop i;
array x {9};
set;
filter=0;
do i=1 to 9; if x{i} NE 123456789 then filter+x{i}; end;
run;
&star. proc print; title "ROUND &round: data=phase2(&dsname)"; run;
data &dsname._filter;
keep &dsname._no &dsname._filter;
set;
&dsname._no=_n_;
&dsname._filter=filter;
run;
&star. proc print; title "ROUND &round: data=&dsname._filter"; run;
%mend make_filter;
*========================================================================;
%macro all_filter; %* Synthesize three filters of row, column and box.;
%reconstruct;
%make_filter(row);
%make_filter(col);
%make_filter(box);
proc sort data=cell; by row_no; run;
data all_filter; merge cell row_filter; by row_no; run;
proc sort data=all_filter; by col_no; run;
data all_filter; merge all_filter col_filter; by col_no; run;
proc sort data=all_filter; by box_no; run;
data all_filter; merge all_filter box_filter; by box_no; run;
proc sort data=all_filter; by row_no; run;
&star. proc print; title "ROUND &round: data=all_filter"; run;
data filter;
drop i xrow_filter xcol_filter xbox_filter;
length filter $ 9;
length xrow_filter $ 9;
length xcol_filter $ 9;
length xbox_filter $ 9;
set all_filter;
xrow_filter=row_filter;
xcol_filter=col_filter;
xbox_filter=box_filter;
do i=1 to 9; if substr(xrow_filter,i,1)=i OR
substr(xcol_filter,i,1)=i OR
substr(xbox_filter,i,1)=i then substr(filter,i,1)=i;
else substr(filter,i,1)=0;
end;
if v NE 0 then filter=" ";
run;
&star. proc print; title "data=filter"; run;
data find_cell;
drop i;
set filter;
zero_cnt=0;
if filter=" " then return;
do i=1 to 9; if substr(filter,i,1)=0 then zero_cnt+1; end;
run;
&star. proc print; title "ROUND &round: data=find_cell"; run;
data candidate;* Find candidate numbers for each cell by applying 'filter';
set find_cell;
if filter=" " then return;
candidate=123456789-filter;
run;
&star. proc print; title "ROUND &round: data=candidate"; run;
%mend all_filter;
*========================================================================;
%macro solve(row_col_box_no); %* Operation (1);
data cell;
keep v row_no col_no box_no found;
set candidate;
if zero_cnt NE 1 then return;
do i=1 to 9; if substr(filter,i,1)=0 then do; v=i; found=1; end; end;
run;
&star. proc print; title "ROUND &round: data=cell(2)"; run;
proc sort data=cell; by row_no; run;
data original;
keep a1-a9;
retain a1-a9;
array a {9} $ 1;
set cell; by row_no;
if first.row_no then i=0;
i+1;
a{i}=v;
if last.row_no;
run;
&star. proc print; title "ROUND &round: data=original(2) Easy Update from
&row_col_box_no"; run;
%let skip_sw=0;
proc sort data=candidate; by &row_col_box_no; run;
data select1;
keep &row_col_box_no all_candidate cnt_no1-cnt_no9;
length all_candidate $ 90;
retain all_candidate;
length xcandidate $ 9;
array cnt_no {9};
set candidate; by &row_col_box_no;

xcandidate=candidate;
if first.&row_col_box_no then all_candidate=" ";
all_candidate=trim(left(xcandidate || all_candidate));
if last.&row_col_box_no then do; do i=1 to 9;
cnt_no{i}=0;
do k=1 to 81;
if substr(all_candidate,k,1)=i then cnt_no{i}+1;
end;
end;
output;
end;
run;
&star. proc print; title "ROUND &round: data=select1"; run;
data select2;
keep &row_col_box_no cnt_no1-cnt_no9;
array cnt_no {9};
set select1;
do i=1 to 9;
if cnt_no{i}=1 then do; output; call symput("skip_sw",1); return; end;
end;
run;
&star. proc print; title "ROUND &round: data=select2"; run;
%if &skip_sw=1 %then %do;
data select3;
keep row_no col_no box_no candidate cnt_no1-cnt_no9;
merge select2(in=in1) candidate; by &row_col_box_no;
if in1;
run;
&star. proc print; title "ROUND &round: data=select3"; run;
data select4;
drop xcandidate i;
array cnt_no {9};
length xcandidate $ 9;
set select3;
do i=1 to 9;
if cnt_no{i}=1 then do; xcandidate=candidate;
if substr(xcandidate,i,1)=i then
do; v=i; output; end;
end;
end;
run;
&star. proc print; title "ROUND &round: data=select4 (New found numbers)"; run;
proc sort data=select4; by row_no; run;
data found_nos;
keep new1-new9 row_no mactch_key;
array new {9} $ 1;
retain new1-new9;
set select4; by row_no;
mactch_key=row_no;
do i=1 to 9; if i=row_no then new{col_no}=v; end;
if last.row_no then output;
do i=1 to 9; new{col_no}=" "; end;
run;
&star. proc print; title "ROUND &round: data=found_nos (Only new found numbers)"; run;
data originalx;
set original;
mactch_key=_n_;
run;
&star. proc print; title "ROUND &round: data=originalx"; run;
data original;
keep a1-a9;
array a {9} $ 1;
array new {9} $ 1;
merge originalx found_nos; by mactch_key;
do i=1 to 9; if new{i} NE . then a{i}=new{i}; end;
run;
%end;
&star. proc print;
title "ROUND &round: data=original(updated) from &row_col_box_no"; run;
%mend solve;
*========================================================================;
%macro find_two_choices(row_col_box_no); %* Operation (2): Update 'filter';
data xcandidate;
set candidate;
if zero_cnt=2;
run;
proc sort data=xcandidate; by &row_col_box_no zero_cnt candidate; run;
&star. proc print data=xcandidate;
title "ROUND &round: Cells with only two candidates: &row_col_box_no";
run;
data two_candidates;
keep &row_col_box_no candidate;
set xcandidate; by &row_col_box_no candidate;
if first.&row_col_box_no=1 then delete;
if first.candidate=0;
run;
&star. proc print data=two_candidates;
title "ROUND &round: data=two_candidates: &row_col_box_no";
run;
data two_candidates(drop=buffer candidate);
set two_candidates;
length buffer $ 9;
buffer=candidate;
candidate_copy=candidate;
candidate1=indexc(buffer,"123456789");
if candidate1 NE . then buffer=translate(buffer,"0",candidate1);
candidate2=indexc(buffer,"123456789");
run;
&star. proc print data=two_candidates;
title "ROUND &round: data=two candidates: &row_col_box_no"; run;
proc sort data=candidate; by &row_col_box_no; run;
data merge_candidate(drop=candidate_copy);
length vvv 8;
merge candidate two_candidates; by &row_col_box_no;
if candidate EQ candidate_copy then dont_change="NO";
if zero_cnt=1 then do; vvv=right(translate(candidate," ","0")); v=vvv; end;
run;
&star. proc print data=merge_candidate;
title "ROUND &round: data=merge_candidate: &row_col_box_no";
run;
data choose_candidate(drop=xxcandidate);
set merge_candidate;
length xxcandidate $ 9;
if candidate1 EQ . OR dont_change="NO" then return;
xxcandidate=candidate;
if candidate=. then return;
substr(xxcandidate,candidate1,1)="0"; candidate=translate(xxcandidate,"0"," ");
substr(xxcandidate,candidate2,1)="0"; candidate=translate(xxcandidate,"0"," ");
run;
&star. proc print data=choose_candidate;
title "ROUND &round: data=choose_candidate: &row_col_box_no";
run;
data candidate;
keep filter row_no col_no box_no v row_filter col_filter box_filter zero_cnt
candidate;
set choose_candidate;
if v NE 0 OR dont_change="NO" OR candidate1=. then return;
substr(filter,candidate1,1)=candidate1;
substr(filter,candidate2,1)=candidate2;
zero_cnt=0;
do i=1 to 9; if substr(filter,i,1)=0 then zero_cnt+1; end;
run;
&star. proc print data=candidate;
title "ROUND &round: data=candidate updated from two candidates: &row_col_box_no";
run;
%mend find_two_choices;
*=========================================================================;
%macro find_check;
%* Set SAS macro variable 'found' to 1 if a new number has been found in this round.;
%* Set SAS macro variable 'not_yet' to the No. of cells unsolved.;
proc compare data=original_before compare=original out=result noprint; run;
&star. proc print data=result; &star. var a1-a9;
title "ROUND &round: data=result: X <- Newly found"; run;
data found;
keep found_sw;
set result end=final;
array a {9} $;
retain found_sw 0;
do i=1 to 9; if a{i} NE "." then found_sw=1; end;
if final then do; call symput("found",found_sw); output; end;
run;
&star. proc print data=found; title "ROUND &round: If new numbers were found,
found_sw=1 "; run;
data _null_;
set original;
array a {9} $ 1;
do i=1 to 9; if a{i}="0" then not_yet+1; end;
call symput("not_yet",not_yet);
run;
%mend find_check;
*=========================================================================;
%macro repeat;
%* Run 'puzzle_solve_final.sas' recursively when new correct numbers are found;
%* When no new numbers were found, execute Operation (2).;
%if &found=1
%then %include &run_solve;
%else %do; %find_two_choices(row_no);
%find_two_choices(col_no);
%find_two_choices(box_no);
data final;
set candidate;
if filter=" " then return;
candidate=123456789-filter;
run;
&star. proc print data=final;
title"ROUND &round: data=final";

run;
%solve(row_no);
%solve(col_no);
%solve(box_no);
%end;
%mend repeat;
*=========================================================================;
%macro verify; %* Judge if the board situation becomes illegal or not,
after adding candidate numbers.;
%reconstruct;
data verify;
length all $ 9;
array a {9} $ 1;
array cnt_no {9};
retain wrong 0;
set row col box;
do i=1 to 9; substr(all,i,1)=a{i}; end;
do i=1 to 9;
cnt_no{i}=0;
do j=1 to 9; if substr(all,j,1)=i then cnt_no{i}+1; end;
do k=1 to 9; if cnt_no{k}>=2 then wrong=1; end;
end;
call symput("wrong",wrong);
if wrong=1 then stop;
run;
&star. proc print data=verify; title"verify!"; run;
%mend verify;
*=========================================================================;
%macro once_again3; %* Control of Operation (3);
%if &not_yet=0 %then %output;
%else
%do; %if &found=1 %then %include &run_solve;
%else
%do; %if &set3_no=0 %then %loop_again3;
%else
%do; %if &set3_no=&op3_no
%then;
%else
%do; %set_original(3,&set3_no,set3_no);
%include &run_solve;
%end;
%end;
%end;
%end;
%mend once_again3;
*=========================================================================;
%macro loop_again3; %* Create new candidate board situations in Operation (3);
data original_operation2;
set original;
run;
%check_no(&select_no);
%operation_candidate(3,&zero_all,&number,&op3_no,op3_no,&select_no);
%set_original(3,&set3_no,set3_no);
%include &run_solve;
%mend loop_again3;
*=========================================================================;
%macro check_no(n1);
%* preliminary process for creating candidate board situations in Operation (3).
%* Set the No. of cells with only two candidate numbers to macro variable 'number'.;
%* Set the No. of candidate board situations created in Operation (3) to macro
variable 'zero_all'.;
data x2candidate;
set final;
if zero_cnt=2 then do; cnt+1; output; end;
%global number;
call symput ("number",cnt);
run;
%zero(2);
data x3candidate;
set final;
if zero_cnt=3;
run;
%zero(3);
data xxxcandidate;
set x2candidate x3candidate;
if _N_<=&n1.;
run;
&star. proc print; title"xxxcandidate"; run;
data zero_candidate;
array a{&n1.};
retain a1-a&n1.;
set xxxcandidate end=finish;
a{_N_}=zero_cnt;
if finish=1;
run;
&star. proc print; title"zero_candidate"; run;
data zero_candidate;
array a{&n1.};
set zero_candidate;
all_cnt=1;
do i=1 to &n1.; all_cnt=all_cnt*a{i}; end;
%global zero_all;
call symput ("zero_all",all_cnt);
run;
%mend check_no;
*=========================================================================;
%macro zero(no); %* Get candidate numbers from a selected cell.;
data x&no.candidate;
set x&no.candidate;
length buffer $ 9;
buffer=candidate;
%do i=1 %to &no.;
candidate&i=indexc(buffer,"123456789");
if candidate&i NE . then buffer=translate(buffer,"0",candidate&i);
%end;
run;
%mend zero;
*=========================================================================;
%macro operation_candidate(n1,n2,n3,n4,n5,n6);
%* Make all candidate board situations from the combination of
all possible candidate numbers for selected cells;
data two_candidates;
keep row_no col_no xx1-xx3;
set xxxcandidate;
%do i=1 %to 3;
xx&i=candidate&i;
%end;
run;
&star. proc print;title"data=two_candidates";run;
data two_candidates;
array v{&n2.};
set two_candidates;
do x=1 to &n6.;
if xx3=.
then do; repeat=2**(_N_-1);
do i=1 to &n2.; v{i}=xx2; end;

do i=1 to &n2. by repeat*2;
do j=i to i+repeat-1; v{j}=xx1; end;
end;
end;
else do; repeat=3**(_N_-1-&n3.);
do i=1 to &n2.; v{i}=xx3; end;
do i=1 to &n2. by repeat*3;
do j=i to i+repeat-1; v{j}=xx1; end;
do j=i+repeat to i+repeat*2-1; v{j}=xx2; end;
end;
end;
end;
run;
&star. proc print; run;
%do i=1 %to &n2;
%keep_pair(&i);
%end;
&star. proc print;title"keep_data";run;
%let xxxcnt=&n4;
%do i=1 %to &n2;
%let xxxcnt=%eval(&xxxcnt+1);
%operation_original(&n1,&i,&xxxcnt);
%end;
%let &n5=&xxxcnt;
%mend operation_candidate;
*=========================================================================;
%macro keep_pair(no);
%* Make SAS data sets, each of which represents candidate numbers for selected cells.;
data keep_pair&no;
keep row_no col_no v&no;
set two_candidates;
run;
%mend keep_pair;
*=========================================================================;
%macro operation_original(x1,x2,x3);
%* Make all candidate board situations by merging SAS data sets 'keep_pair&x2'
and 'final';
proc sort data=keep_pair&x2; by row_no col_no; run;
proc sort data=final; by row_no col_no; run;
data original_&x1._&x3.;
keep row_no col_no v;
merge final keep_pair&x2; by row_no col_no;
if v&x2 NE . then v=v&x2;
run;
data original_&x1._&x3.;
keep a1-a9;
retain a1-a9;
array a {9} $ 1;
set original_&x1._&x3.; by row_no;
if first.row_no then i=0;
i+1;
a{i}=v;
if last.row_no;
run;
&star. ods listing close;
&star. ods html
file="&output\original_&x1._&x3.(&rotate._ROUND&round._OPE3_ORIGINAL&set3_no.).xls";
&star. proc print data=original_&x1._&x3.;
title "original_&x1._&x3."; run;
&star. ods html close;
&star. ods listing;
%mend operation_original;

*=========================================================================;
%macro set_original(n1,n2,n3);
%* Set next candidate board situation to SAS data set ORIGINAL;
%let n2=%eval(&n2+1);
data original;
set original_&n1._&n2.;
run;
%let &n3=&n2;
%let round=0;
%mend set_original;
*=========================================================================;
%macro turn; %* Get back the current board situaton to original shape, if it was
rotated;
data original;
keep x row col;
array a {9} $ 1;
set original;
do i=1 to 9; row=_n_; col=i;
x=a{i};
output;;
end;
run;
data original;
keep x new_row new_col;
rename new_row=row new_col=col;
set original;
new_row=col;
new_col=10-row;
run;
proc sort; by row; run;
data original;
keep a1-a9;
array a {9} $ 1;
retain a1-a9;
set; by row;
do i=1 to 9; a{col}=x; end;
if last.row;
run;
%mend turn;
*=========================================================================;
%macro reconstruct; %* Make four SAS data sets, CELL, ROW, COL and BOX from
ORIGINAL;
data cell;
keep v row_no col_no box_no;
array a {9} $ 1;
*array row_no {9};
*array col_no {9};
*array box_no {9};
set original;
do i=1 to 9; row_no=_n_; col_no=i;
box_no=MAX(INT((_n_-1)/3),0)+INT((i-1)/3)+2*INT((_n_-1)/3)+1;
v=a{i};
output;;
end;
run;
/*
proc print data=cell; title "data=cell"; run;
*/
*-------------------------------------------;
proc sort data=cell; by row_no; run;
data row;
keep a1-a9;
array a {9} $ 1;
retain a1-a9;

set cell; by row_no;
a{col_no}=v;
if last.row_no then output;
run;
options nocenter ps=100;
/*
proc print data=row; title "data=row"; run;
*/
*-------------------------------------------;
proc sort data=cell; by col_no; run;
data col;
keep a1-a9;
array a {9} $ 1;
retain a1-a9;
set cell; by col_no;
a{row_no}=v;
if last.col_no then output;
run;
/*
proc print data=col; title "data=col"; run;
*/
*-------------------------------------------;
proc sort data=cell; by box_no; run;
data box;
keep a1-a9;
array a {9} $ 1;
retain a1-a9 i;
set cell; by box_no;
if first.box_no then i=1;
a{i}=v; i+1;
if last.box_no then output;
run;
/*
proc print data=box; title "data=box"; run;
*/
%mend reconstruct;
*=========================================================================;
%macro output;
%* When the solution was found, it is displayed in the OUTPUT window,
otherwise the solving engine will be executed recursively by using
rotated board situations one after another. In case no solution can
be found after three rotations, only the intermidiate solution gained
from Operations (1) and (2) is displayed;
options nonotes nosource;
%if &not_yet=0 %then %do; %*<-----; %* Go to display the solution in the OUTPUT
window;
%if &rotate=1 %then; %* Display now, because of no rotations done;
%else %do i=1 %to %eval(5-&rotate); %turn; %end;
%* Rotate clockwise to put it in the original posision;
proc printto;
data;
endtime=DATETIME();
put endtime= time.;
call symput("endtime",endtime);
run;
data;
time=&endtime-&starttime;
put time= time.;
time=round(time);
call symput("time",time);
run;

proc print data=original;title1 "Problem # &Q. was successfully solved.";
title2 "No. of 90-Degree Clockwise Rotations: %eval(&rotate.-
1)";
title3 "No. of Repetitions of Running
'puzzle_solve_final.sas': &new_round";
title4 "Run Time: &time. Seconds"; run;
%abort;
%end; %*<-----;
%else %do; %*======;
%if &rotate<4 %then
%do;
%* In case no solutons have been found, rotate the board
position 90 degrees clockwise;
%let rotate=%eval(&rotate+1);
%let rotate_sw=0;
%include &run_solve;
%end;
data original;
set original_operation2;
run;
%turn
proc printto;
data;
endtime=DATETIME();
put endtime= time.;
call symput("endtime",endtime);
run;
data;
time=&endtime-&starttime;
put time= time.;
time=round(time);
call symput("time",time);
run;
proc print data=original;title1 "Problem # &Q. was not be able to be solved.";
title2 "No. of Repetitions of Running
'puzzle_solve_final.sas': &new_round";
title3 "Run Time: &time. Seconds"; run;
%abort;
%end; %*======;
%mend output;
*=========================================================================;
%macro all; %* Solving Engine;
%* Operation (1) starts;
%all_filter; %if &wrong=1 %then %goto another_one;
%solve(row_no);
%all_filter; %if &wrong=1 %then %goto another_one;
%solve(col_no);
%all_filter; %if &wrong=1 %then %goto another_one;
%solve(box_no);
%find_check;
%* Operation (2) starts;
%repeat;
%find_check;
%verify;
%another_one: %*label;
%* Operation (3) starts;
%once_again3;
%output;
%mend all;
*=========================================================================;
