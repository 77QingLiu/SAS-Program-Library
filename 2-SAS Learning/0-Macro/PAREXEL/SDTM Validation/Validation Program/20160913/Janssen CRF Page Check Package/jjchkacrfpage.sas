/*-----------------------------------------------------------------------------
PAREXEL INTERNATIONAL LTD
Sponsor / Protocol No: Janssen Research & Development / <protocol>
PXL Study Code: <TIME code>
SAS Version: <version number>
Operating System: UNIX
-------------------------------------------------------------------------------
Author: <author> $LastChangedBy: $

Creation / modified: <date in DDMMMYYYY format> / $LastChangedDate: $

Program Location/name: $HeadURL: $

  Files Created: jjchkacrfpage.log
                 VALDEF Page Potential Issue.txt
                 VARDEF Page Potential Issue.txt                 				 
  			 
  Program Purpose: This program is to check aCRF annotation's page number with Define XML.
  
  VARDEF Page Potential Issue.txt 
  => Check all variables page number.
  VALDEF Page Potential Issue.txt 
  => For nested domains, check the 1st level page (--CAT). All other levels, need to be checked manually.
  => For non-nested domains, check all the value lists page numbers.
  => QS is a nested domain but since except for QSALL, other QSTESTCD are unique, so we treat it like non-nested 
     domains. Only one QSTESTCD (QSALL) needs to be checked manually, which will depend on the different QSCAT. 
                      
  Note: You need to export comments from aCRF and save it as acrf.xfdf. Then put the define.xml
        and acrf.xfdf together with two xml mapping file (acrf.map / definexml.map) in the same folder.        
                     
                 
  Macro Parameters: 
    Name:                root
        Allowed Values:  Please put the folder path, for example /user1/shenb/jjcrfpage/226483/
        Default Value:   REQUIRED
        Description:     Character string containing the folder path in unix
        
    Name:                nest_domain
        Allowed Values:  In VALDEF, there are some value lists need nested, the default value
                         are CC|DS|FT|LB based on latest Janssen metadata(2016-07-18).
                         For QS, it's also a common nested domain, however except for QSALL, 
                         in most of cases the QSTESTCD will be unique, so we don't include QS here.   
                         In case you want to update this, please list all the nested domains here and 
                         separate them by pipe (|). For example: CC|DS|FT|LB                          
        Default Value:   OPTIONAL
        Description:     Character string containing the nested domains separated by pipe (|).        
-------------------------------------------------------------------------------
MODIFICATION HISTORY: Subversion $Rev: $
-----------------------------------------------------------------------------*/

/********************************************************************************
 *  Generated by XML Mapper, 904000.0.0.20130522190000_v940
 ********************************************************************************/
%macro jjchkacrfpage(root=, nest_domain=CC|DS|FT|LB);  
option missing = " " ls = 170 ps = 50;  
%let acrf=%str(acrf) ;     
%let dm_var = SUBJID|RFSTDTC|RFENDTC|RFXSTDTC|RFXENDTC|RFICDTC|RFPENDTC|DTHDTC|
              DTHFL|SITEID|INVID|INVNAM|BRTHDTC|AGE|AGEU|SEX|RACE|ETHNIC|ARMCD|ARM|
              ACTARMCD|ACTARM|COUNTRY;           

/*
 *  Environment
 */
filename  annotate "&root.&acrf..xfdf";
filename  SXLEMAP "&root.acrf.map";    /*this is aCRF's annotation map file */
libname   annotate xmlv2 xmlmap=SXLEMAP access=READONLY;

/* Only use the freetext / p / span */ 

DATA freetext (keep = freetext_ORDINAL freetext_page); 
    SET annotate.freetext;
    freetext_page = freetext_page+1;  
run;

DATA p; 
    SET annotate.p; 
run;

DATA span; 
    SET annotate.span; 
run;

/* Step 1: Link p with span by p_ORDINAL */
data annotation(keep = freetext_ORDINAL annotation);
  length annotation $500 ;
  merge p span ;
  by p_ORDINAL;
  freetext_ORDINAL= body_ORDINAL ;
  annotation= catx(' ', p, span);
run;

/* Step 2: Link annotation with freetext by freetext_ORDINAL */ 
data final data_delete;
  merge annotation(in=a) freetext(in=b);
  by freetext_ORDINAL;
  if a;
  if find(annotation,'NOT SUBMITTED')>0 or 
     find(upcase(annotation),'ANNOTATION')>0 or
     find(upcase(annotation),'NOTE:')>0  or     
     find(upcase(annotation),'VIA RELREC')>0 or 
     missing(annotation) then output data_delete;              
  else if prxmatch("/^[A-Z]{2}\s?=\s?\w+/", annotation) or 
          (upcase(substr(annotation,1,2))="IF" and not prxmatch("/^(If\s?(yes|no|checked),)/i", annotation))   
          then output data_delete;
  else output final;          
run;

proc sort data= final nodupkey;
  by freetext_page freetext_ORDINAL annotation;
run;

data table1;
  set final ;
  annotation = tranwrd(annotation,'= ','=');
  annotation = tranwrd(annotation,' =','='); 
  annotation = prxchange("s/^(If\s?(yes|no|checked),)//i",-1 , annotation);  
run;

/* QNAM in VALDEF*/
data valdef_supp1 ;
  length VALUEOID $200. VALVAL $100.;
  set table1;
  where compress(annotation) like '%inSUPP__whenIDVAR=%';         
  VALVAL= scan(annotation,1,'= ');
  var2= substr(annotation, find(annotation,'SUPP'), 6 ) ;
  VALUEOID= catx('.', var2,'QNAM');
  keep VALUEOID VALVAL freetext_page freetext_ORDINAL ;
run;

proc sort data= valdef_supp1 nodupkey;
  by VALUEOID VALVAL freetext_page;
run;

data valdef_supp(keep = VALUEOID VALVAL PAGE freetext_ORDINAL);  
  set valdef_supp1;
  length PAGE $200.;
  by VALUEOID VALVAL freetext_page;
  retain page ;
  if first.VALVAL then call missing(page) ;
  page= catx(', ',page, freetext_page) ;  
  if last.VALVAL;
run;

/* 1st nested valuelist in VALDEF (CAT / TESTCD) */

%let nest_domain1 = "%sysfunc(tranwrd(&nest_domain.,|,%bquote(",")))"; 

data valdef_cattestcd;
  set table1;
  where prxmatch("/([A-Z]{2})(CAT)|(TESTCD)/", annotation) and index(annotation,"=")>0;  
  annotation= tranwrd(compbl(annotation),' when ','^');
  annotation= tranwrd(compbl(annotation),' and ','^');
  array element $100 var1-var5;
   do i= 1 to 5;
      element[i]= scan(annotation,i,'^');                              
      VAR=strip(compbl(scan(element[i], 1, ",")));      
      /* For non-nested domain, only keep the TESTCD valuelist / For nested domain, only keep the CAT valuelist */
        if (prxmatch("/^([A-Z]{2})(CAT)/", VAR) and substr(scan(VAR, 1, "="), 1, 2) in (&nest_domain1.)) or 
        (prxmatch("/^([A-Z]{2})(TESTCD)/", VAR) and substr(scan(VAR, 1, "="), 1, 2) not in (&nest_domain1.))                  
           then output;                           
   end;
  drop i ;
run;

proc sort data= valdef_cattestcd nodupkey;
  by  VAR  freetext_page ;
run ;

data valdef_cattestcd_1 (keep = VALUEOID VALVAL PAGE freetext_ORDINAL);
  length VALUEOID $200. VALVAL $100. PAGE $200.;
  set valdef_cattestcd;
  by  VAR  freetext_page ;
  retain page ;  
  if first.VAR then call missing(page);
  page= catx( ', ',page,freetext_page ) ;
  VALUEOID= catx('.', substr(var,1,2),scan(var,1,'=') );
  VALVAL=scan(var,2,'=');
  if last.VAR  then output;
run;
            
data valdef;
  set valdef_cattestcd_1 valdef_supp ;
run;

proc sort data= valdef nodupkey;
  by VALUEOID VALVAL page ;
run;

/*vardef main*/
data vardef1;
  set table1;
  annotation1= tranwrd(annotation,'[','^');
  annotation1= tranwrd(annotation1,']','^');
  annotation1= tranwrd(annotation1,' when ','^');
  annotation1= tranwrd(annotation1,' and ','^');
  annotation1= tranwrd(annotation1,' in ','^');
  annotation1= prxchange("s/(\w+)(\s?)=(\s?)NOT DONE/$1$2/",-1,annotation1);
  annotation1= tranwrd(annotation1,', ',',');
  annotation1= tranwrd(annotation1,' ,',',');
  annotation1= prxchange("s/(COVAL)(\s?)(\^)(\s?)(IDVAR)(\s?)=(\s?)(\w+)/$1/",-1,annotation1);
  annotation1= strip(annotation1);
run;                              

data vardef2 (keep = annotation freetext_: var);
  set vardef1;  
  array element $30 var1-var20;
  if prxmatch("/in SUPP/", annotation) then delete;
  do i = 1 to 20 ;
    element[i]=scan(annotation1,i,',^');    
    if find(element[i],'=')>0 then   element[i]= scan( element[i], 1,'=') ;
    if length(element[i])>8 then put "WAR" "NING:[PXL] variable "   element[i] " length more than 8 char" ;    
    else do;
        VAR= strip(compbl(element[i])) ;        
        if ^missing(VAR) and (VAR in ("IETESTCD", "QSSTRESC", "QSSTRESN") or 
        (substr(VAR,3) ne "TESTCD" and substr(VAR,3) ne "STRESC")) then output;                                
    end;                       
  end;
run;

proc sort data= vardef2 out = vardef3 nodupkey;
  by VAR  freetext_page;
run;

%let dm_var1 = "%sysfunc(tranwrd(&dm_var.,|,%bquote(",")))"; 
 
data vardef_main1 ;
  length DATASET $8 VARIABLE $8 ;
  set vardef3;
  if VAR in(&dm_var1.) then DATASET='DM';  
  else DATASET=substr(strip(var),1,2) ;
  VARIABLE=VAR;
  keep DATASET VARIABLE freetext_: ;
run;

proc sort data= vardef_main1 nodupkey;
  by DATASET VARIABLE freetext_page ;
run;

data vardef_main;
length page $200 ;
  retain page;
  set vardef_main1;
  by DATASET VARIABLE freetext_page ;
  if first.VARIABLE then call missing(page);
  page= catx(', ' , page, freetext_page);
  if last.VARIABLE then output;
  drop freetext_page ;
run;

/*vardef supp*/
data vardef_supp1;
length DATASET $8 ;
  set Valdef_supp1;
  DATASET = scan(VALUEOID,1) ;  
run;

proc sort data= vardef_supp1 nodupkey;
  by DATASET freetext_page ;
run;

data vardef_supp2;
length page $200 ;
  retain page;
  set vardef_supp1;
  by DATASET freetext_page ;
  if first.DATASET then call missing(page);
  page= catx(', ' , page, freetext_page);
  if last.DATASET then output;
  drop freetext_page VALUEOID  VALVAL;
run;

data vardef_supp;
length VARIABLE $8;
	set vardef_supp2;
	VARIABLE= 'QLABEL' ; output;
	VARIABLE= 'QVAL';output;
run;

data vardef;    
    set vardef_main vardef_supp;
run;

proc sort data = vardef nodupkey;
    by DATASET VARIABLE page;
run;        

/********************************************************************************
 *  read define xml 
 ********************************************************************************/

/*
 *  Environment
 */
filename  define "&root.define.xml";
filename  SXLEMAP "&root.definexml.map";
libname   define xmlv2 xmlmap=SXLEMAP access=READONLY;

/*
 *  Local Extraction
 */

/* Only use the ItemRef / ItemDef */
 
DATA ItemRef; 
    SET define.ItemRef; 
run;

DATA ItemDef; 
    SET define.ItemDef(keep = ItemDef_ORDINAL OID Name Origin); 
run;

data _NULL_;
	if 0 then set itemref nobs=n;
	call symputx('valdefrow',n);
	stop;
run;

data xml_vardef_raw  xml_valdef_raw;
   set itemdef ;
   if  ItemDef_ORDINAL <= &valdefrow  then output xml_vardef_raw ;
   else output xml_valdef_raw ;
run;

/*************************************************************************/
/*           build the vardef and valdef structure                       */
/*************************************************************************/

/* For VALDEF - Main, only check the 1st nested valuelist in VALDEF (CAT / TESTCD)
   Note: For QS, revise the VALUEOID to QS.QSTESTCD. As in most of cases, except for QSALL, 
   the QSTESTCD will be unique, no need to consider QSCAT. */ 
      
data xml_valdef(keep = VALUEOID VALVAL XML_PAGE);
  length VALUEOID $200. VALVAL $100. XML_PAGE $200.;
  set xml_valdef_raw (where=(index(upcase(Origin), "CRF") > 0));                     
  if scan(OID, -2, ".") = "QSTESTCD" and name ne "QSALL" then VALUEOID = "QS.QSTESTCD";   
  else VALUEOID= catx(".", scan(OID, 1, "."), scan(OID, 2, "."));
  VALVAL=name;
  XML_PAGE= tranwrd(compress(substr(Origin, index(Origin, "CRF")),',', 'kd'), ',',', ');
  if count(OID, ".")=2 or VALUEOID = "QS.QSTESTCD";
run;

proc sort data= xml_valdef ;
  by VALUEOID  VALVAL ;
run;

proc sort data= valdef;
  by VALUEOID  VALVAL ;
run;

ods listing close;

title "VALDEF page check finding" ;

data chk_valdef;
  merge xml_valdef valdef ;
  by VALUEOID  VALVAL ;
  file "&root.VALDEF Page Potential Issue.txt" print;
  if page ne xml_page then do ;
    put  VALUEOID  VALVAL  'Annotation page NO. is ' page ', but page in Define is ' xml_page ;
  end;
run;

ods listing;

data xml_vardef(keep = DATASET VARIABLE XML_PAGE);
  length XML_PAGE $200. DATASET $8. VARIABLE $8.;
  set xml_vardef_raw ;
  where index(upcase(Origin), "CRF") > 0;          
  DATASET = scan(OID, 1,'.') ;
  VARIABLE  = scan(OID, 2,'.') ;
  XML_PAGE= tranwrd(compress(substr(Origin, index(Origin, "CRF")),',', 'kd'), ',',', ');
run;

proc sort data= xml_vardef ;
  by DATASET VARIABLE;
run;

proc sort data= vardef ;
  by DATASET VARIABLE;
run;

ods listing close;

title "VARDEF page check finding" ;

data chk_vardef;
  merge xml_vardef vardef ;
  by DATASET  VARIABLE ;
  file "&root.VARDEF Page Potential Issue.txt" print;
  if page ne xml_page then do ;
    put  DATASET  VARIABLE  'Annotation page NO. is ' page ', but page in Define is ' xml_page ;
  end;
run;

ods listing;

%mend jjchkacrfpage;
%jjchkacrfpage(root=/user1/shenb/jjcrfpage/226483/);